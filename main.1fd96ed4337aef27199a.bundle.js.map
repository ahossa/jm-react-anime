{"version":3,"file":"main.1fd96ed4337aef27199a.bundle.js","sources":["webpack:///./src/lib/index.js"],"sourcesContent":["import React, { useLayoutEffect, useState } from \"react\";\nimport anime from \"animejs\";\n\nconst Anime = props => {\n  let {\n    id,\n    className,\n    style,\n    type,\n    children,\n    explodeOptions,\n    control,\n    setMeta\n  } = props;\n  const [state, setState] = useState(\"\");\n  const [lastControl, setLastControl] = useState(\"\");\n  const [player, setPLayer] = useState({});\n  let words = [];\n  let chars = [];\n  let explodedChildren = [];\n  if (props.explode) {\n    React.Children.map(children, child => {\n      if (typeof child === \"string\") {\n        words = child.split(\" \");\n        chars = child.split(\"\");\n      }\n    });\n\n    let options = {\n      className: explodeOptions.name,\n      style: { display: \"inline-block\" }\n    };\n    if (props.explode === \"characters\") {\n      chars.map(char => {\n        explodedChildren.push(\n          React.createElement(\"span\", options, char === \" \" ? \"\\u00A0\" : char)\n        );\n      });\n    } else if (props.explode === \"words\") {\n      words.map(word => {\n        explodedChildren.push(React.createElement(\"span\", options, word));\n        explodedChildren.push(React.createElement(\"span\", options, \"\\u00A0\"));\n      });\n    }\n  }\n\n  const Play = event => {\n    let mode = props[event];\n    let { animeConfig } = props;\n    if (mode === undefined || mode === null) return;\n    if (mode.length > 1) {\n      let config = animeConfig\n        ? animeConfig\n        : { easing: \"easeOutExpo\", duration: 750 };\n      if (setMeta) {\n        config.update = () =>\n          setMeta({\n            progress: tl.progress,\n            currentTime: tl.currentTime,\n            duration: tl.duration\n          });\n      }\n      let tl = anime.timeline(config);\n\n      mode.map(anim => tl.add(anim));\n      return tl;\n    } else {\n      mode.map(anim => anime(anim));\n    }\n  };\n\n  useLayoutEffect(() => {\n    setPLayer(Play(\"initial\"));\n  }, []);\n\n  useLayoutEffect(() => {\n    if (props[state] === undefined) {\n      if (props[\"_onUpdate\"]) {\n        Play(\"_onUpdate\");\n      }\n      if (control) {\n        if (lastControl !== control) {\n          if (typeof control !== \"object\") {\n            setLastControl(control);\n            player[control]();\n          } else {\n            setLastControl(control);\n            player[control[0]](player.duration * (control[1] / 100));\n          }\n        }\n      }\n    } else {\n      Play(state);\n    }\n    setState(\"\");\n    return () => {\n      if (props[\"_onUnmount\"]) {\n        Play(\"_onUnmount\");\n      }\n    };\n  });\n\n  const options = {\n    id,\n    style,\n    className,\n    onClick: e => {\n      if (props[\"_onClick\"]) setState(\"_onClick\");\n      try {\n        props.onClick(e);\n      } catch (e) {}\n    },\n    onContextMenu: e => {\n      if (props[\"_onContextMenu\"]) setState(\"_onContextMenu\");\n      try {\n        props.onContextMenu(e);\n      } catch (e) {}\n    },\n    onDoubleClick: e => {\n      if (props[\"_onDoubleClick\"]) setState(\"_onDoubleClick\");\n      try {\n        props.onDoubleClick(e);\n      } catch (e) {}\n    },\n    onDrag: e => {\n      if (props[\"_onDrag\"]) setState(\"_onDrag\");\n      try {\n        props.onDrag(e);\n      } catch (e) {}\n    },\n    onDragEnd: e => {\n      if (props[\"_onDragEnd\"]) setState(\"_onDragEnd\");\n      try {\n        props.onDragEnd(e);\n      } catch (e) {}\n    },\n    onDragEnter: e => {\n      if (props[\"_onDragEnter\"]) setState(\"_onDragEnter\");\n      try {\n        props.onDragEnter(e);\n      } catch (e) {}\n    },\n    onDragExit: e => {\n      if (props[\"_onDragExit\"]) setState(\"_onDragExit\");\n      try {\n        props.onDragExit(e);\n      } catch (e) {}\n    },\n    onDragLeave: e => {\n      if (props[\"_onDragLeave\"]) setState(\"_onDragLeave\");\n      try {\n        props.onDragLeave(e);\n      } catch (e) {}\n    },\n    onDragOver: e => {\n      if (props[\"_onDragOver\"]) setState(\"_onDragOver\");\n      try {\n        props.onDragOver(e);\n      } catch (e) {}\n    },\n    onDragStart: e => {\n      if (props[\"_onDragStart\"]) setState(\"_onDragStart\");\n      try {\n        props.onDragStart(e);\n      } catch (e) {}\n    },\n    onDrop: e => {\n      if (props[\"_onDrop\"]) setState(\"_onDrop\");\n      try {\n        props.onDrop(e);\n      } catch (e) {}\n    },\n    onMouseDown: e => {\n      if (props[\"_onMouseDown\"]) setState(\"_onMouseDown\");\n      try {\n        props.onMouseDown(e);\n      } catch (e) {}\n    },\n    onMouseEnter: e => {\n      if (props[\"_onMouseEnter\"]) setState(\"_onMouseEnter\");\n      try {\n        props.onMouseEnter(e);\n      } catch (e) {}\n    },\n    onMouseLeave: e => {\n      if (props[\"_onMouseLeave\"]) setState(\"_onMouseLeave\");\n      try {\n        props.onMouseLeave(e);\n      } catch (e) {}\n    },\n    onMouseMove: e => {\n      if (props[\"_onMouseMove\"]) setState(\"_onMouseMove\");\n      try {\n        props.onMouseMove(e);\n      } catch (e) {}\n    },\n    onMouseOut: e => {\n      if (props[\"_onMouseOut\"]) setState(\"_onMouseOut\");\n      try {\n        props.onMouseOut(e);\n      } catch (e) {}\n    },\n    onMouseOver: e => {\n      if (props[\"_onMouseOver\"]) setState(\"_onMouseOver\");\n      try {\n        props.onMouseOver(e);\n      } catch (e) {}\n    },\n    onMouseUp: e => {\n      if (props[\"_onMouseUp\"]) setState(\"_onMouseUp\");\n      try {\n        props.onMouseUp(e);\n      } catch (e) {}\n    }\n  };\n  return React.createElement(\n    type || \"div\",\n    options,\n    props.explode === undefined ? children : explodedChildren\n  );\n};\nconst ReactAnime = {\n  Anime: Anime,\n  stagger: anime.stagger\n};\n\nexport default ReactAnime;\n"],"mappings":"AA6NA","sourceRoot":""}